<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SimTrace</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: grid;
        grid-template-columns: 260px 1fr 320px;
        gap: 12px;
        padding: 12px;
      }
      #canvas {
        border: 1px solid #ccc;
        width: 100%;
        height: 520px;
      }
      .panel {
        border: 1px solid #ddd;
        padding: 10px;
        border-radius: 8px;
      }
      .runItem {
        padding: 8px;
        border: 1px solid #eee;
        border-radius: 8px;
        margin-bottom: 8px;
        cursor: pointer;
      }
      .runItem:hover {
        background: #f7f7f7;
      }
      .runActive {
        background: #f2f2f2;
        border-color: #ddd;
      }
      .event {
        padding: 6px;
        border-bottom: 1px solid #eee;
      }
      .active {
        background: #f2f2f2;
      }
      input[type="range"] {
        width: 100%;
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap;
      }
      button {
        padding: 6px 10px;
        border: 1px solid #ddd;
        background: white;
        border-radius: 8px;
        cursor: pointer;
      }
      button:hover {
        background: #f7f7f7;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      select {
        padding: 6px 10px;
        border: 1px solid #ddd;
        border-radius: 8px;
      }
      .muted {
        color: #666;
        font-size: 12px;
      }
      .statgrid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 6px;
        margin-top: 8px;
      }
      .stat {
        border: 1px solid #eee;
        border-radius: 8px;
        padding: 8px;
      }
      .stat b {
        display: block;
        font-size: 12px;
        color: #666;
      }
      .stat span {
        font-size: 16px;
      }
      #statusBadge {
        padding: 2px 8px;
        border: 1px solid #ddd;
        border-radius: 999px;
      }
      #diagOut {
        margin-top: 8px;
        white-space: pre-wrap;
      }
    </style>
  </head>

  <body>
    <div class="panel">
      <h3>Runs</h3>
      <div id="runsList" class="muted">Loading…</div>

      <hr />

      <div id="runMeta" class="muted"></div>
      <div class="statgrid" id="stats"></div>

      <hr />

      <div class="row">
        <label class="muted">Scenario</label>
        <select id="scenarioSel">
          <option value="warehouse" selected>Warehouse robot</option>
          <option value="delivery">Delivery bot (ground)</option>
          <option value="sar">Search & rescue</option>
        </select>
      </div>

      <div class="muted" style="margin-top:8px;">
        Status: <b id="statusBadge">—</b>
      </div>
      <div class="muted" id="policyText" style="margin-top:6px;"></div>

      <hr />

      <button id="diagBtn" disabled>Diagnose Run</button>
      <div id="diagOut" class="muted"></div>
    </div>

    <div class="panel">
      <h3>Replay</h3>
      <canvas id="canvas" width="900" height="520"></canvas>

      <div class="row" style="margin-top:10px;">
        <button id="playBtn">Play</button>
        <button id="pauseBtn" disabled>Pause</button>

        <label class="muted">Speed</label>
        <select id="speedSel">
          <option value="0.5">0.5x</option>
          <option value="1" selected>1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
        </select>
      </div>

      <div style="margin-top:10px;">
        <input id="timeSlider" type="range" min="0" max="200" value="0" />
        <div>Time: <span id="timeLabel">0.0</span>s</div>
      </div>
    </div>

    <div class="panel">
      <h3>Events</h3>
      <div id="events" class="muted">Load a run.</div>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const runsList = document.getElementById("runsList");
      const runMeta = document.getElementById("runMeta");
      const statsDiv = document.getElementById("stats");

      const slider = document.getElementById("timeSlider");
      const timeLabel = document.getElementById("timeLabel");
      const eventsDiv = document.getElementById("events");

      const playBtn = document.getElementById("playBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const speedSel = document.getElementById("speedSel");

      const scenarioSel = document.getElementById("scenarioSel");
      const statusBadge = document.getElementById("statusBadge");
      const policyText = document.getElementById("policyText");

      const diagBtn = document.getElementById("diagBtn");
      const diagOut = document.getElementById("diagOut");

      const SCENARIOS = {
        warehouse: {
          name: "Warehouse robot",
          limits: { near_collision: 1, stuck: 0 },
          weights: { near_collision: 3, stuck: 2 }
        },
        delivery: {
          name: "Delivery bot (ground)",
          limits: { near_collision: 2, stuck: 1 },
          weights: { near_collision: 2, stuck: 2 }
        },
        sar: {
          name: "Search & rescue",
          limits: { near_collision: 3, stuck: 2 },
          weights: { near_collision: 1, stuck: 3 }
        }
      };

      let runIndex = null;
      let run = null;
      let playing = false;
      let timer = null;

      function worldToCanvas(x, y) {
        const scale = 80;
        const cx = 120 + x * scale;
        const cy = 460 - y * scale;
        return [cx, cy];
      }

      function draw(t) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!run) return;

        ctx.beginPath();
        run.frames.forEach((f, i) => {
          const [cx, cy] = worldToCanvas(f.x, f.y);
          if (i === 0) ctx.moveTo(cx, cy);
          else ctx.lineTo(cx, cy);
        });
        ctx.stroke();

        let best = run.frames[0];
        for (const f of run.frames) {
          if (Math.abs(f.t - t) < Math.abs(best.t - t)) best = f;
        }

        const [bx, by] = worldToCanvas(best.x, best.y);
        ctx.beginPath();
        ctx.arc(bx, by, 7, 0, Math.PI * 2);
        ctx.fill();
      }

      function renderEvents(t) {
        if (!run) return;
        eventsDiv.innerHTML = "";
        run.events.forEach(e => {
          const div = document.createElement("div");
          div.className = "event" + (e.t <= t ? " active" : "");
          div.textContent = `[${e.t.toFixed(1)}s] ${e.type}: ${e.detail}`;
          eventsDiv.appendChild(div);
        });
      }

      function setTime(t) {
        if (!run) return;
        const idx = Math.max(0, Math.min(Math.floor(t / run.dt), Number(slider.max)));
        slider.value = String(idx);
        const t2 = idx * run.dt;
        timeLabel.textContent = t2.toFixed(1);
        draw(t2);
        renderEvents(t2);
      }

      function stopPlayback() {
        playing = false;
        playBtn.disabled = false;
        pauseBtn.disabled = true;
        if (timer) clearInterval(timer);
        timer = null;
      }

      function startPlayback() {
        if (!run) return;
        playing = true;
        playBtn.disabled = true;
        pauseBtn.disabled = false;

        const speed = Number(speedSel.value);

        timer = setInterval(() => {
          const idx = Number(slider.value);
          const next = idx + speed;
          if (next >= Number(slider.max)) {
            setTime(Number(slider.max) * run.dt);
            stopPlayback();
            return;
          }
          slider.value = String(Math.floor(next));
          const t = Number(slider.value) * run.dt;
          timeLabel.textContent = t.toFixed(1);
          draw(t);
          renderEvents(t);
        }, 100);
      }

      function computeScenarioStatus(r, scenarioKey) {
        const sc = SCENARIOS[scenarioKey];
        const s = r.stats || {};
        const events = r.events || [];

        const near = (s.near_collision_count ?? events.filter(e => e.type === "near_collision").length);
        const stuck = (s.stuck_count ?? events.filter(e => e.type === "stuck").length);

        const score =
          near * sc.weights.near_collision +
          stuck * sc.weights.stuck;

        let status = "PASS";
        if (near > sc.limits.near_collision || stuck > sc.limits.stuck) status = "FAIL";
        else if (near === sc.limits.near_collision || stuck === sc.limits.stuck) status = "WARN";

        return { near, stuck, score, status, limits: sc.limits, weights: sc.weights };
      }

      function renderScenarioUI() {
        if (!run) {
          statusBadge.textContent = "—";
          policyText.textContent = "";
          return;
        }
        const key = scenarioSel.value;
        const out = computeScenarioStatus(run, key);
        statusBadge.textContent = out.status;
        policyText.textContent =
          `Limits: near-collision ≤ ${out.limits.near_collision}, stuck ≤ ${out.limits.stuck} | ` +
          `Weights: near=${out.weights.near_collision}, stuck=${out.weights.stuck} | ` +
          `Score: ${out.score}`;
      }

      function diagnoseRun(r, scenarioKey) {
        const sc = SCENARIOS[scenarioKey];
        const s = r.stats || {};
        const events = r.events || [];

        const near = s.near_collision_count ?? events.filter(e => e.type === "near_collision").length;
        const stuck = s.stuck_count ?? events.filter(e => e.type === "stuck").length;
        const duration = s.duration_s ?? r.frames[r.frames.length - 1].t;
        const distance = s.distance_m ?? 0;

        let severity = "LOW";
        if (near >= sc.limits.near_collision || stuck >= sc.limits.stuck) severity = "MEDIUM";
        if (near > sc.limits.near_collision || stuck > sc.limits.stuck) severity = "HIGH";

        let cause = "No major behavioral issues detected.";
        let fixes = ["- Keep current parameters; expand stress tests."];

        if (stuck > 0) {
          cause =
            "Robot enters a deadlock state and fails to recover. This usually indicates missing recovery logic or over-aggressive turning.";
          fixes = [
            "- Add recovery behavior: reverse → rotate → retry.",
            "- Detect oscillation and force a large escape turn.",
            "- Add timeout-based recovery when no progress is made."
          ];
        }

        if (near > sc.limits.near_collision) {
          cause =
            "Obstacle avoidance triggers too late, causing repeated near-collisions.";
          fixes = [
            "- Increase obstacle clearance threshold.",
            "- Reduce speed near obstacles.",
            "- Apply smoothing to distance sensor readings."
          ];
        }

        if (stuck > 0 && near > sc.limits.near_collision) {
          cause =
            "Compound failure: late avoidance combined with no recovery creates collision-deadlock loops.";
          fixes = [
            "- Increase clearance distance AND add recovery behavior.",
            "- Cap angular velocity to reduce oscillation.",
            "- Introduce wall-follow fallback in tight spaces."
          ];
        }

        const statusObj = computeScenarioStatus(r, scenarioKey);

        return `
SIMTRACE DIAGNOSIS
Scenario: ${sc.name}
Run ID: ${r.run_id}

Policy result: ${statusObj.status}
Severity: ${severity}

Metrics:
- Duration: ${duration.toFixed(1)}s
- Distance: ${distance.toFixed(1)}m
- Near-collisions: ${near}
- Stuck events: ${stuck}

Likely root cause:
${cause}

Recommended fixes:
${fixes.join("\n")}

Suggested next test:
- Re-run under "${sc.name}" with narrowed passages and compare PASS/WARN/FAIL + score.
`.trim();
      }

      async function loadRun(file, highlightId) {
        stopPlayback();
        const res = await fetch(`../runs/${file}`);
        run = await res.json();

        runMeta.innerHTML = `
          <div><b>ID:</b> ${run.run_id}</div>
          <div><b>Sim:</b> ${run.meta.sim}</div>
          <div><b>World:</b> ${run.meta.world}</div>
          <div><b>Robot:</b> ${run.meta.robot}</div>
          <div class="muted">Controller: ${run.meta.controller}</div>
        `;

        const s = run.stats || {};
        statsDiv.innerHTML = `
          <div class="stat"><b>Duration</b><span>${(s.duration_s ?? run.frames[run.frames.length-1].t).toFixed(1)}s</span></div>
          <div class="stat"><b>Distance</b><span>${(s.distance_m ?? 0).toFixed(1)}m</span></div>
          <div class="stat"><b>Near Collisions</b><span>${s.near_collision_count ?? run.events.filter(e=>e.type==="near_collision").length}</span></div>
          <div class="stat"><b>Stuck</b><span>${s.stuck_count ?? run.events.filter(e=>e.type==="stuck").length}</span></div>
        `;

        const duration = s.duration_s ?? run.frames[run.frames.length - 1].t;
        slider.max = Math.max(1, Math.floor(duration / run.dt));
        slider.value = "0";

        document.querySelectorAll(".runItem").forEach(el => el.classList.remove("runActive"));
        const active = document.getElementById(`run_${highlightId}`);
        if (active) active.classList.add("runActive");

        eventsDiv.textContent = "";
        setTime(0);
        renderScenarioUI();

        diagBtn.disabled = false;
        diagOut.textContent = "Click Diagnose Run to generate an incident report.";
      }

      async function loadRunIndex() {
        const res = await fetch("../runs/index.json");
        runIndex = await res.json();

        runsList.innerHTML = "";
        runIndex.runs.forEach(r => {
          const div = document.createElement("div");
          div.id = `run_${r.id}`;
          div.className = "runItem";
          div.innerHTML = `<b>${r.label}</b><div class="muted">${r.file}</div>`;
          div.onclick = () => loadRun(r.file, r.id);
          runsList.appendChild(div);
        });

        if (runIndex.runs.length > 0) {
          const first = runIndex.runs[0];
          loadRun(first.file, first.id);
        }
      }

      slider.oninput = () => {
        if (!run) return;
        stopPlayback();
        const t = Number(slider.value) * run.dt;
        timeLabel.textContent = t.toFixed(1);
        draw(t);
        renderEvents(t);
      };

      playBtn.onclick = startPlayback;
      pauseBtn.onclick = stopPlayback;

      speedSel.onchange = () => {
        if (playing) {
          stopPlayback();
          startPlayback();
        }
      };

      scenarioSel.onchange = () => {
        renderScenarioUI();
        if (run && !diagBtn.disabled) {
          diagOut.textContent = "Click Diagnose Run to generate an incident report.";
        }
      };

      diagBtn.onclick = () => {
        if (!run) return;
        diagOut.textContent = diagnoseRun(run, scenarioSel.value);
      };

      loadRunIndex();
    </script>
  </body>
</html>
